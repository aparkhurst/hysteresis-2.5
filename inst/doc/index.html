<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Hysteresis</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{An Introduction to the hysteresis package}
-->

<h1>Hysteresis</h1>

<h2>An R package for fitting rate-dependent hysteretic loops</h2>

<p>Hysteresis loops occur when an output variable can have multiple possible values at one input value depending on the history of the system and the direction of change in the input. This package contains functions to simulate, fit, and obtain parameter values along with their standard errors (Yang and Parkhurst) from hysteresis loops of the form
\[ x_{t}=b_{x}cos(2t\pi/T+\phi)+c_{x}+e_{x,t} \]
\[ y_{t}=b_{y}*cos(2t\pi/T+\phi)^{n}+R*sin(2t\pi/T+\phi)^{m}+c_{y}+e_{y,t} \]</p>

<p>where e is a random error term. These generalized transcendental equations (Lapshin) form a hysteresis loop for a given frequency or period and set of time points t=1,2&hellip;n.</p>

<p>The plot below uses the function <strong>mloop</strong> which simulates hysteresis loops to show the effects of choosing various odd values for n and m.</p>

<pre><code class="r">library(knitr)
library(hysteresis)
</code></pre>

<pre><code>## Error: package &#39;hysteresis&#39; was built before R 3.0.0: please re-install it
</code></pre>

<pre><code class="r">par(mfrow = c(3, 3), mai = c(0, 0.2, 0.2, 0), ann = FALSE, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, 
    oma = c(0, 0, 3, 0))

for (i in c(1, 3, 15)) {
    for (j in c(1, 3, 15)) {
        obj &lt;- mloop(m = i, n = j, n.points = 100, period = 99)
        plot(floop(obj$x, obj$y, m = i, n = j, period = 99), xlim = c(-0.8, 
            0.8), ylim = c(-0.8, 0.8))
        if (i == 1) 
            title(paste(&quot;n=&quot;, j, sep = &quot;&quot;))
        if (j == 1) 
            title(ylab = paste(&quot;m=&quot;, i, sep = &quot;&quot;), line = 0, cex.sub = 2)
    }
}
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">title(&quot;Hysteresis Loops for Odd Values of m and n&quot;, outer = TRUE)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<p>It is also possible to use even values for n.</p>

<pre><code class="r">
par(mfrow = c(3, 3), mai = c(0, 0.2, 0.2, 0), ann = FALSE, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, 
    oma = c(0, 0, 3, 0))

for (i in c(1, 3, 15)) {
    for (j in c(2, 4, 16)) {
        obj &lt;- mloop(m = i, n = j, n.points = 100, period = 99)
        plot(floop(obj$x, obj$y, m = i, n = j, period = 99), xlim = c(-0.8, 
            0.8), ylim = c(-0.8, 0.8))
        if (i == 1) 
            title(paste(&quot;n=&quot;, j, sep = &quot;&quot;))
        if (j == 2) 
            title(ylab = paste(&quot;m=&quot;, i, sep = &quot;&quot;), line = 0, cex.sub = 2)
    }
}
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">title(&quot;Hysteresis Loops for Odd Values of m and Even Values of n&quot;, outer = TRUE)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<p>A special case is when n=1 and m=1, this makes the hysteresis loop an ellipse. The centroid of the hysteresis loop is given by cx and cy as shown in the plot below of ellipses.</p>

<pre><code class="r">obj &lt;- mloop(cx = 0, cy = 0, n.points = 100, period = 99)
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">obj2 &lt;- mloop(cx = 1.5, cy = 0, n.points = 100, period = 99)
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">obj3 &lt;- mloop(cx = 0, cy = 1.5, n.points = 100, period = 99)
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">plot(obj$x, obj$y, type = &quot;l&quot;, xlim = c(-2, 3), ylim = c(-2, 3), xlab = &quot;x&quot;, 
    ylab = &quot;y&quot;, col = &quot;#6600CC&quot;, main = &quot;Centroid Given by cx and cy&quot;)
</code></pre>

<pre><code>## Error: object &#39;obj&#39; not found
</code></pre>

<pre><code class="r">points(0, 0, pch = 19, col = &quot;#6600CC&quot;)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<pre><code class="r">text(x = 0, y = 0.15, &quot;(cx=0,cy=0)&quot;, col = &quot;#6600CC&quot;)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<pre><code class="r">lines(obj2$x, obj2$y, col = &quot;#00FF66&quot;)
</code></pre>

<pre><code>## Error: object &#39;obj2&#39; not found
</code></pre>

<pre><code class="r">points(1.5, 0, pch = 19, col = &quot;#00FF66&quot;)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<pre><code class="r">text(x = 1.5, y = 0.15, &quot;(cx=1.5,cy=0)&quot;, col = &quot;#00FF66&quot;)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<pre><code class="r">lines(obj3$x, obj3$y, col = &quot;#FF6600&quot;)
</code></pre>

<pre><code>## Error: object &#39;obj3&#39; not found
</code></pre>

<pre><code class="r">points(0, 1.5, pch = 19, col = &quot;#FF6600&quot;)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<pre><code class="r">text(x = 0, y = 1.65, &quot;(cx=0,cy=1.5)&quot;, col = &quot;#FF6600&quot;)
</code></pre>

<pre><code>## Error: plot.new has not been called yet
</code></pre>

<p>The saturation points describe where the direction of the input changes sign. The distances from the central point to the saturation points are given by b.x and b.y (saturation points at (\( c_{x} \pm b_{x},c_{y} \pm b_{y} \)))</p>

<pre><code class="r">for (i in c(1, 2, 4)) {
    obj &lt;- mloop(b.x = i, n.points = 100, period = 99)
    plot(obj$x, obj$y, xlim = c(-5, 10), ylim = c(-1.4, 1.4), type = &quot;l&quot;, main = paste(&quot;b.x=&quot;, 
        i, sep = &quot;&quot;), xlab = &quot;x&quot;, ylab = &quot;y&quot;)
    points(i, 0.8, pch = 19)
    legend(i, 1, legend = c(&quot;Saturation Point&quot;, &quot;x=cx+b.x&quot;, &quot;y=cy+b.y&quot;), bty = &quot;n&quot;)
}
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">for (i in c(0.8, 2, 4)) {
    obj &lt;- mloop(b.y = i, n.points = 100, period = 99)
    plot(obj$x, obj$y, xlim = c(-1, 2), ylim = c(-5, 5), type = &quot;l&quot;, main = paste(&quot;b.y=&quot;, 
        i, sep = &quot;&quot;), xlab = &quot;x&quot;, ylab = &quot;y&quot;)
    points(0.6, i, pch = 19)
    legend(0.6, i, legend = c(&quot;Saturation Point&quot;, &quot;x=cx+b.x&quot;, &quot;y=cy+b.y&quot;), bty = &quot;n&quot;)
}
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<p>Retention, or the output split point R, is the vertical distance from center to upper loop trajectory.</p>

<pre><code class="r">for (i in c(1, 2, 4)) {
    obj &lt;- mloop(retention = i, n.points = 100, period = 99)
    plot(obj$x, obj$y, xlim = c(-1, 1), ylim = c(-5, 5), type = &quot;l&quot;, main = paste(&quot;retention=&quot;, 
        i, sep = &quot;&quot;), xlab = &quot;x&quot;, ylab = &quot;y&quot;)
    segments(0, 0, 0, i)
    text(0.3, 0.5, &quot;Retention&quot;)
}
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<p>Finally the phase.angle, \( \phi \), changes the location of points along the loop, but does not change the form of the loop itself. When phase.angle is zero, the loop starting point is also the saturation point.</p>

<pre><code class="r">obj &lt;- mloop(retention = 0.5, n.points = 100, period = 99)
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">for (i in c(0, 90, 180, 260)) {
    plot(obj$x, obj$y, type = &quot;l&quot;, xlab = &quot;x&quot;, ylab = &quot;y&quot;, main = &quot;Starting Points for Different Values of phase.angle&quot;, 
        xlim = c(-0.6, 0.8))
    obj2 &lt;- mloop(phase.angle = i, retention = 0.5, n.points = 1, period = 99)
    points(obj2$x, obj2$y, pch = 19, col = &quot;gold&quot;, cex = 2)
    points(obj2$x, obj2$y, col = &quot;gold&quot;, cex = 4)
    text(obj2$x + 0.08, obj2$y, round(i, 2))
}
</code></pre>

<pre><code>## Error: object &#39;obj&#39; not found
</code></pre>

<h2>Fitting Ellipses</h2>

<h3>The Process</h3>

<p><strong>Hysteresis</strong> contains one method for fitting hysteresis loops given any n and m in the function <strong>floop</strong>. 
In the special case of an ellipse where n=1 and m=1, four methods are available in the function <strong>fel</strong>. 
The two-step simple harmonic regression (harmonic2) method, the default, generally produces estimates that are less 
biased and have lower variances than those produced by the other methods. Since the focus is on rate-dependent hysteresis, 
knowledge of time for the observations is required (or if unknown, times may be assumed to be equally spaced). On the 
other hand, if the objective is solely to fit an ellipe, observation times are not needed for the other three methods.</p>

<pre><code class="r">set.seed(24)
ellipse1 &lt;- mel(method = 2, retention = 0.4, b.x = 0.6, b.y = 0.8, cx = 0, cy = 0, 
    sd.x = 0.1, sd.y = 0.1, phase.angle = 0, period = 24, n.points = 24)
</code></pre>

<pre><code>## Error: could not find function &quot;mel&quot;
</code></pre>

<pre><code class="r"># The function **mel** can be used as an alternative to **mloop** for
# simulating ellipses, and it is useful because it offers four different
# ellipse parameterizations.
model &lt;- fel(ellipse1$x, ellipse1$y, method = &quot;harmonic2&quot;, period = 24, times = &quot;equal&quot;)
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r"># period=24 and times=&#39;equal&#39; are used to say that 24 equally spaced
# points make up an ellipse.
model
</code></pre>

<pre><code>## Error: object &#39;model&#39; not found
</code></pre>

<p>In addition to the fundamental values of the model, <strong>fel</strong> also calculates a wide variety of derived parameters. Definitions for these parameters can be found using <strong>help(loop.parameters)</strong>.</p>

<pre><code class="r">model$Estimates
</code></pre>

<pre><code>## Error: object &#39;model&#39; not found
</code></pre>

<p>A wide variety of functions have S3 methods for objects of class <strong>ellipsefit</strong> produced by <strong>fel</strong>. The most important of these is <strong>summary.ellipsefit</strong> which can be used to bootstrap and summarize models produced by <strong>fel</strong>.</p>

<pre><code class="r">summary(model, N = 10000, studentize = TRUE)
</code></pre>

<pre><code>## Error: object &#39;model&#39; not found
</code></pre>

<p>Another important S3 method is for the function <strong>plot</strong>.</p>

<pre><code class="r">
plot(model, main = &quot;2-step Simple Harmonic Regression Ellipse Example&quot;)
</code></pre>

<pre><code>## Error: object &#39;model&#39; not found
</code></pre>

<p>In addition, S3 methods exist for <strong>fitted</strong>, <strong>print</strong>, and <strong>residuals</strong>.</p>

<h3>Comparison of Ellipse Estimation Methods</h3>

<p>The two most useful ellipse estimation methods implemented by <strong>fel</strong> are the &#39;harmonic2&#39; and &#39;direct&#39; methods. The &#39;direct&#39; method (Flusser and Halir) fits an ellipse without requiring time information and is more stable than the other two methods in <strong>fel</strong>, &#39;lm&#39; and &#39;nls&#39;, which are based on linear least squares and ellipse-specific nonlinear regression respectively. The &#39;direct&#39; method does not yet have delta method standard errors available.</p>

<pre><code class="r">modeldirect &lt;- fel(ellipse1$x, ellipse1$y, method = &quot;direct&quot;, period = 24, times = &quot;equal&quot;)
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r">summodel &lt;- summary(modeldirect, N = 10000, studentize = TRUE)
</code></pre>

<pre><code>## Error: object &#39;modeldirect&#39; not found
</code></pre>

<pre><code class="r">summodel
</code></pre>

<pre><code>## Error: object &#39;summodel&#39; not found
</code></pre>

<pre><code class="r">plot(modeldirect, main = &quot;Direct Ellipse Example&quot;)
</code></pre>

<pre><code>## Error: object &#39;modeldirect&#39; not found
</code></pre>

<p>The &#39;direct&#39; method uses different fundamental parameters than the &#39;harmonic2&#39; method. However summary results for b.x, b.y, and retention are still available from the matrix of  values produced by summary.ellipsefit.</p>

<pre><code class="r">summodel$values
</code></pre>

<pre><code>## Error: object &#39;summodel&#39; not found
</code></pre>

<p>The four plots below illustrate a comparison of the four methods for fitting an ellipse to simulated data. The data 
points are based on the simulated red ellipse; the fitted ellipse is in black.</p>

<pre><code class="r">set.seed(13)
par(mfrow = c(2, 2))
halfellipse &lt;- mel(method = 2, cx = 20, cy = 25, retention = 1.2, b.x = 14, 
    b.y = 0.8, sd.x = 1, sd.y = 0.2, period = 24, n.points = 16, phase.angle = pi/2)
</code></pre>

<pre><code>## Error: could not find function &quot;mel&quot;
</code></pre>

<pre><code class="r">halftrueellipse &lt;- mel(method = 2, cx = 20, cy = 25, retention = 1.2, b.x = 14, 
    b.y = 0.8, phase.angle = 0, period = 99, n.points = 100)
</code></pre>

<pre><code>## Error: could not find function &quot;mel&quot;
</code></pre>

<pre><code class="r">harmodel &lt;- fel(halfellipse$x, halfellipse$y, method = &quot;harmonic2&quot;, period = 24, 
    times = &quot;equal&quot;)
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r">dirmodel &lt;- fel(halfellipse$x, halfellipse$y, method = &quot;direct&quot;, period = 24, 
    times = &quot;equal&quot;)
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r">lmmodel &lt;- fel(halfellipse$x, halfellipse$y, method = &quot;lm&quot;, period = 24, times = &quot;equal&quot;)
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r">nlsmodel &lt;- fel(halfellipse$x, halfellipse$y, method = &quot;nls&quot;, period = 24, times = &quot;equal&quot;, 
    control = c(n.iter = 500))
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r">plot(harmodel, main = &quot;Harmonic2 Model&quot;, xlim = c(5, 34), ylim = c(23.4, 26.9))
</code></pre>

<pre><code>## Error: object &#39;harmodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<pre><code class="r">plot(dirmodel, main = &quot;Direct Model&quot;, xlim = c(5, 34), ylim = c(23.4, 26.9))
</code></pre>

<pre><code>## Error: object &#39;dirmodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<pre><code class="r">plot(lmmodel, main = &quot;Linear Model&quot;, xlim = c(5, 34), ylim = c(23.4, 26.9))
</code></pre>

<pre><code>## Error: object &#39;lmmodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<pre><code class="r">plot(nlsmodel, main = &quot;Non-Linear Model&quot;, xlim = c(5, 34), ylim = c(23.4, 26.9))
</code></pre>

<pre><code>## Error: object &#39;nlsmodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<h2>Bootstrapping Fitted Ellipses</h2>

<p>The function <strong>summary.ellipsefit</strong> bootstraps the x and y residuals of a fitted ellipse separately to produce 
standard errors and less biased estimates of ellipse parameters. These residuals are easy to obtain using the 
&#39;harmonic2&#39; model which gives fitted points when fitting the ellipse, but somewhat more difficult to obtain from the 
other methods which do not use time as a variable in fitting the model and therefore cannot place observations on the 
ellipse. The function <strong>fel</strong>, therefore, gives two methods for producing x and y residuals using these methods. If 
times=&ldquo;unknown&rdquo;, fitted values are taken to be the points on the ellipse closest to their realized values. If 
times=&ldquo;equal&rdquo; or a numeric vector and the period of the ellipse is known, then the distances between points on the 
ellipse are taken as given and only the starting point of the ellipse is chosen to minimize the sum of squared distances 
between fitted and realized values. If times are available, it is always better to give them, as the residuals given 
by times=&#39;unknown&#39; will lead to standard errors for ellipse parameters that are biased downwards. If times really are 
unknown, a good alternative is to use the delta standard errors from the function <strong>delta.error</strong> which is currently 
available for every method except the direct.</p>

<p>In addition, residuals can be studentized within the <strong>summary.ellipsefit</strong> function by keeping studentize=TRUE, which is the default. Simulations suggest that studentization improves 95% bootstrap coverage intervals for all four methods.</p>

<p>The value N gives the number of bootstrap replicates, its default is 1000 which may be  low in some situations (Efron).
In each replication, residuals are resampled with replacement and added to the original fitted values produced by <strong>fel</strong>. The simulated ellipse is then refit using the original method and parameter estimates are obtained. The standard deviations of these estimates are then used to give parameter standard errors, and less biased parameter estimates are obtained by subtracting the estimated bias produced by the method, mean(bootstrap estimates) - (original estimate), from the original estimate.
Note, if reproducable results are desired use set.seed() command.</p>

<h3>Comparison of Bootstrapped Ellipses</h3>

<p>The fitted black ellipses from above are then bootstrapped to reduce bias.</p>

<pre><code class="r">par(mfrow = c(2, 2))
harsummodel &lt;- summary(harmodel, N = 1000, studentize = TRUE)
</code></pre>

<pre><code>## Error: object &#39;harmodel&#39; not found
</code></pre>

<pre><code class="r">dirsummodel &lt;- summary(dirmodel, N = 1000, studentize = TRUE)
</code></pre>

<pre><code>## Error: object &#39;dirmodel&#39; not found
</code></pre>

<pre><code class="r">lmsummodel &lt;- summary(lmmodel, N = 1000, studentize = TRUE)
</code></pre>

<pre><code>## Error: object &#39;lmmodel&#39; not found
</code></pre>

<pre><code class="r">nlssummodel &lt;- summary(nlsmodel, N = 1000, studentize = TRUE)
</code></pre>

<pre><code>## Error: object &#39;nlsmodel&#39; not found
</code></pre>

<pre><code class="r">plot(harsummodel, main = &quot;Bootstrapped Harmonic2 Model&quot;, xlim = c(5, 34), ylim = c(23.4, 
    26.9))
</code></pre>

<pre><code>## Error: object &#39;harsummodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<pre><code class="r">plot(dirsummodel, main = &quot;Bootstrapped Direct Model&quot;, xlim = c(5, 34), ylim = c(23.4, 
    26.9))
</code></pre>

<pre><code>## Error: object &#39;dirsummodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<pre><code class="r">plot(lmsummodel, main = &quot;Bootstrapped Lm Model&quot;, xlim = c(5, 34), ylim = c(23.4, 
    26.9))
</code></pre>

<pre><code>## Error: object &#39;lmsummodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<pre><code class="r">plot(nlssummodel, main = &quot;Bootstrapped Nls Model&quot;, xlim = c(5, 34), ylim = c(23.4, 
    26.9))
</code></pre>

<pre><code>## Error: object &#39;nlssummodel&#39; not found
</code></pre>

<pre><code class="r">lines(halftrueellipse$x, halftrueellipse$y, col = &quot;red&quot;)
</code></pre>

<pre><code>## Error: object &#39;halftrueellipse&#39; not found
</code></pre>

<h2>Fitting Multiple Ellipses Simultaneously</h2>

<p>The argument subjects in the function <strong>fel</strong> can be used to fit multiple ellipses, which share the same period, 
at one time. In this case <strong>fel</strong> produces an object of class <strong>ellipsefitlist</strong> instead of <strong>ellipsefit</strong>, and methods for 
objects of class <strong>ellipsefitlist</strong> exist for the functions <strong>summary</strong>, <strong>plot</strong>, and <strong>print</strong>. Ellipses are separated 
by levels given by the argument subjects, which can be either a vector or a list of vectors treated as factors. Below 
is an example of fitting multiple ellipses using the subjects option.</p>

<pre><code class="r">data(EllipseData)
models &lt;- fel(EllipseData$X, EllipseData$Y, method = &quot;harmonic2&quot;, subjects = EllipseData$subjects, 
    subset = EllipseData$repeated == 1)
</code></pre>

<pre><code>## Error: could not find function &quot;fel&quot;
</code></pre>

<pre><code class="r">models
</code></pre>

<pre><code>## Error: object &#39;models&#39; not found
</code></pre>

<pre><code class="r">summodels &lt;- summary(models)
</code></pre>

<pre><code>## Error: object &#39;models&#39; not found
</code></pre>

<pre><code class="r">summodels
</code></pre>

<pre><code>## Error: object &#39;summodels&#39; not found
</code></pre>

<pre><code class="r">plot(summodels, main = &quot;Fitting Multiple Ellipses Simultaneously&quot;)
</code></pre>

<pre><code>## Error: object &#39;summodels&#39; not found
</code></pre>

<h2>To output summary results to excel readable file at current directory</h2>

<pre><code class="r">## write.table(models$Estimates,&#39;file_name.txt&#39;) and
## write.table(summodels$Boot.Estimates,&#39;file_name.txt&#39;)
</code></pre>

<h2>Fitting Hysteresis Loops</h2>

<p>The function <strong>floop</strong> can be used to fit hysteresis loops with specific values of n and m as arguments to <strong>floop</strong>. Below is an example of a 
hysteresis loop with n=5, m=3. </p>

<pre><code class="r">loop &lt;- mloop(n = 5, m = 3, sd.x = 0.02, sd.y = 0.02)
</code></pre>

<pre><code>## Error: could not find function &quot;mloop&quot;
</code></pre>

<pre><code class="r">fitloop &lt;- floop(loop$x, loop$y, n = 5, m = 3, period = 24, times = &quot;equal&quot;)
</code></pre>

<pre><code>## Error: could not find function &quot;floop&quot;
</code></pre>

<pre><code class="r">fitloop$Estimates
</code></pre>

<pre><code>## Error: object &#39;fitloop&#39; not found
</code></pre>

<pre><code class="r">plot(fitloop, main = &quot;Fitted Hysteresis Loop&quot;)
</code></pre>

<pre><code>## Error: object &#39;fitloop&#39; not found
</code></pre>

<pre><code class="r">summary(fitloop)
</code></pre>

<pre><code>## Error: object &#39;fitloop&#39; not found
</code></pre>

<h2>Acknowledgments</h2>

<p>NIFA MRF 25-008/W-2173 Impacts of Stress Factors on Performance, Health, and Well Being of Farm Animals</p>

</body>

</html>

